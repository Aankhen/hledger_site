About testing in the hledger project, as of 201809.

* Kinds of tests

** Unit tests

Unit tests exercise small chunks of functionality.
In hledger, that means a function.
So, many of our functions have one or more unit tests.
These are mostly in hledger-lib, with a few in hledger.


Our unit tests are built with [[http://hackage.haskell.org/package/easytest][easytest]] plus some helpers (provided by Hledger.Utils.Test),
and they follow a consistent pattern, with the intention of keeping them
easy to read (clear, concise),
easy to write (low boilerplate, low cognitive load),
easy to maintain (easy to refactor, robust),
easy to associate with the code under test (easy to view/jump between code & test, easy to estimate coverage),
and
scalable (usable for all devs, suitable for small/large modules/packages, easy to run).
Here's the current pattern (let us know if you see a better way):

#+BEGIN_SRC haskell
module M (
  ...
  easytests_M
)
where
import Hledger       -- includes Hledger.Utils.Test
import SubmoduleFoo  -- submodules, providing easytests_SubmoduleFoo etc.
import SubmoduleBar
...
functionA = ...
functionB = ...
...

easytests_M = tests "M" [ -- group and name..
   tests "functionA" [
     test "something"   $ SOMEEXPR `is` EXPECTEDVALUE  -- name and define a basic test
    ,test "other thing" $ expectParseEq PARSER INPUT EXPECTEDRESULT
    ...
    ]
  ,tests "functionB" [
     _test "blah" $ ...   -- this test will be skipped
    ,test "bleh" $ ... 
    ...
    ]
  ,easytests_SubmoduleFoo
  ,easytests_SubmoduleBar
  ]
#+END_SRC

Here's the quick way to run unit tests while developing:\\
=make ghcid-test= or =make ghcid-test-Hledger.Some.Module=.

As a user, you can also run the unit tests, which are built in to the hledger executable as the [[http://hledger.org/manual#test][test]] command (=hledger test=).
When run this way, all tests are expected to pass; if not, something has gone wrong, please let us know!

** Doc tests

Like unit tests, but defined inside functions' haddock documentation, in the style of a GHCI transcript.
These test functionality, provide usage examples in the API docs, and test those examples, all at once.
They are a bit more finicky and slower than unit tests.
See [[http://hackage.haskell.org/package/doctest][doctest]] for more.

** Functional tests

Functional tests test the overall functioning of the program.
For hledger, that means running =hledger= with various inputs and options and checking for the expected output.
This exercises functionality in the hledger and hledger-lib packages.
We do this with [[http://hackage.haskell.org/package/shelltestrunner][shelltestrunner]].
Tests are defined in files under tests/, grouped by [topic](Issues) (command or major component name).

** Code tests

We have some tests aimed at testing eg code quality, generally defined as make rules, such as:

| =make haddocktest=  | can haddock process all code docs without error                                     |
| =make buildtest=    | does all code build warning free with the default GHC version & stackage snapshot   |
| =make buildtestall= | does the code build warning free with all supported GHC versions/stackage snapshots |

See below for examples.

** Package test suites

Haskell tools like stack and cabal recognise test suites defined in a package's cabal file (or package.yaml file).
These can be run via =stack test=, =cabal test= etc., and they are required to build and pass by services like Stackage.
Here are the currently hledger package test suites:

| package     | test suite | what it runs                                                |
| hledger-lib | doctests   | doctests                                                    |
| hledger-lib | easytests  | unit tests                                                  |
| hledger     | test       | builtin test command (hledger's + hledger-lib's unit tests) |
| hledger-ui  |            |                                                             |
| hledger-web |            |                                                             |
| hledger-api |            |                                                             |

* Coverage

This means how thoroughly the code is tested -
both in breadth (are all parts of the code tested at least a little ?)
and in depth (are all possible code paths, states, situations tested ?).

Our current test coverage can be summarised like so:

| package     | unit | doc | functional |
| hledger-lib | X    | X   | X          |
| hledger     | X    |     | X          |
| hledger-ui  |      |     |            |
| hledger-web |      |     |            |
| hledger-api |      |     |            |

There are ways to generate detailed coverage reports for haskell unit tests, at least.
It would be useful to set this up for hledger.

* How to run tests

Run unit tests:

#+BEGIN_EXAMPLE
$ make unittest
#+END_EXAMPLE

Run doctests:

#+BEGIN_EXAMPLE
$ make doctest
#+END_EXAMPLE

Run functional tests (and unit tests, now):

#+BEGIN_EXAMPLE
$ stack install shelltestrunner
$ make functest
#+END_EXAMPLE

Run the package tests
(unit tests, maybe doctests, but not functional tests)
of all or selected packages.

#+BEGIN_EXAMPLE
$ stack test [PKG]
#+END_EXAMPLE

Run "default tests: package plus functional tests":

#+BEGIN_EXAMPLE
$ make test
#+END_EXAMPLE

Test generation of haddock docs:

#+BEGIN_EXAMPLE
$ make haddocktest
#+END_EXAMPLE

Thorough test for build issues with current GHC:

#+BEGIN_EXAMPLE
$ make buildtest
#+END_EXAMPLE

Thorough test for build issues with all supported GHC versions:

#+BEGIN_EXAMPLE
$ make buildtestall
#+END_EXAMPLE

Run built-in hledger/hledger-lib unit tests via hledger command:

#+BEGIN_EXAMPLE
$ hledger test  # test installed hledger
$ stack build hledger && stack exec -- hledger test  # test just-built hledger
$ hledger test --help
test [TESTPATTERN] [SEED]
  Run the unit tests built in to hledger-lib and hledger,
  printing results on stdout and exiting with success or failure.
  Tests are run in two batches: easytest-based and hunit-based tests.
  If any test fails or gives an error, the exit code will be non-zero.
  If a pattern argument (case sensitive) is provided, only easytests
  in that scope and only hunit tests whose name contains it are run.
  If a numeric second argument is provided, it will set the randomness
  seed for easytests.
#+END_EXAMPLE

Rebuild and rerun hledger/hledger-lib unit tests via ghcid:

#+BEGIN_EXAMPLE
$ make ghcid-test
#+END_EXAMPLE

Rebuild and rerun only some tests via ghcid (see hledger test --help):

#+BEGIN_EXAMPLE
$ make ghcid-test-TESTPATTERN
#+END_EXAMPLE

See all test-related make rules:

#+BEGIN_EXAMPLE
$ make help-test
#+END_EXAMPLE
